Simple Homomorphic Encryption (SHE)

Basics

Homomorphic Encryption allows you to send encrypted data to a third party
and that third party can do computations on the data and return it to you
will all the computations happenning on the encrypted data itself. This
library uses the helib's binArithmetic library to implement as full a C++
semantic as possible. Helib uses the BGV homomorphic encryption system. This
system can do primitive operations of bit level addition and bit level
multiplication. Each operation adds some noise to the result, so only
a limitted number of operations can be done before the noise overwhelms our
actual data. Part of BGV is a way to set the noise level to a lower value
by decrypting our the encrypted value homophorphically. The details aren't
important for the use of SHE, but this affects the performance of any
calculations you do.

The goals of this library.

Helib as been available for about 10 years, and is already used in systems
to provide homomorphic services. It is the "assembler" level of doing
homomorphic encryption, with a few higher level features like binArithmetic.
The latter provides basic functionality like shift, bitwise operations,
addition, subraction, and multiplication. Using helib requires finding
correct parameters, and initializing crypto systems with those parameters.

The goals of this library is to reduce the complexity of initializing your
the system and provide C++ like access to underlying homomorphic operations.

Using SHE

KeyGeneration and management.

To use SHE, you first need to get a keypair. This keyPair is generated using
the SHEGenerate_KeyPair(), which takes a type, a security level, and an
operation level. The operation level sets how many operations you can do before
you need to bootstrap again. The higher the operation level, the slower each
operation will be for a given security level. Security level is the strength
of the system in bits. Several levels are provided that are not really secure,
but allow you to experiment before cranking up to a higher security level.

One you have your keyPair, you can save them to a file, or stream using the
C++ << operators. In a real system, you will want to send the publickey
along with your encrypted data, so that they server can operate on your
encrypted data.

NOTE: in production, only the client needs to generate a keypair, the server
just accepts publicKey along with the encrypted data.

Integer operations.

Encrypted data is stored in various SHEInt classes: SHEInt8, SHEInt16, 
SHEInt32, SHEInt64, SHEUInt8, SHEUInt16, SHEUInt32, SHEUInt64and SHEBool. These
correspond the the C++ types int8_t, int16_t, int32_t, int64_t, uint8_t,
uint16_t, uint32_t, uint64_t, and bool respectively

These classes are all subclasses of SHEInt, so you can implement generic
integer libraries that work on any of these native types by using SHEInt.
All SHEInt constructs must have a publicKey, either explicitly, or implicity.
Simply declare a SHEInt variable, and start using it.

SHEInt16 a(publicKey);
SHEInt16 b(publicKey);
SHEInt16 r(publicKey);

a = 5;
b = -7;

r = a*a + b;

All the basic integer operators are supported except  the ? operator (a?b:c).
Instead you can use a.select(b:c), or select(a,b,c);

Logical and comparison operations return SHEInt and not bool, and there is
no cast from SHEInt to bool. This is because the results of these operations
are encrypted, so they cannot be examined directly in your program. This means
they cannont be used in a if, or as an exit to a loop condition.

  if (a == b)  // This will not work.

This is because the result of the comparison is itself encrypted. So you can't
query the result (unless you decrypt it). What you can do is use the result
to select a value:
  r = (a==b).select(10, 5);

or 
  r = select(a==b, 10, 5);

r will get the selected encrypted value (either 10 or 5) depending on the state
of the comparision. You can use integer constants or SHEInt values or a mix of
values in the select.

To implement a while loop with an encrypted index, you can't use and
encrypted bool result to exit the loop. Instead you need to use a
for loop to loop over all the possibilities and stop updating your variables
when the loop condition 'ends':

   // unencrypted a and b:
   while (a < b) {
    a += 1;
    b >> 1;
  }

  // encrypted a && b, assumes a is not negative...
  SHEBool lbreak(publicKey, false);
  for (int i=0; i < b.getSize(); i++) {
    // lbreak is zero until the condition is reached
    lbreak= lbreak || (a < b);
    // update variables until the lbreak condition occurs
    a = lbreak.select(a, a+1);
    b = lbreak.select(b, b>>1);
  }

Note: it's important to know the actual maximum bound of the while loop, if,
in the above example, a is -b.getSize(), then this loop won't execute as
long as expected an will produce incorrect results.

SHEVector operations.

SHEVector allows you to store a vector or array of encrypted values and access
that array with an encrypted index. In all other ways it functions as a normal
std::vector. When using an encrypted index, you can't assign to it, but you can
use the assign() method:

    SHEInt16 model(publicKey);
    SHEVector<SHEInt16> array(model,1);
    SHEInt16 r(publicKey,5);
    SHEInt16 r2(publicKey);
    SHEInt8 index(publicKey, 3);

    array[1] = SHEInt16(publicKey, 5); // this works because the index is
                                       // unencrypted
    array[3] = r;
    r2 = array[index];                // r2 will get an encrypted value of r
    array[index] = SHEInt16(publicKey, 7) // this will not work.
    array.assign(index,SHEInt16(publicKey, 7)) // use this instead

SHEVectors can store and index any value that has a
<type>select(const SHEInt &, const <type>&, const <type>&); function.
Indexes are type SHEInt.

SHEFp operations

Like SHEInt, SHEFp is a base class used to implement SHEHalfFloat, 
SHEBFloat16, SHEFloat, SHEDouble, SHEExtendedFloat, and SHELongDouble.
Like SHEInt, in needs to be initialized with a publicKey either implicitly
or explicitly. Once you have a float variable, you can assign to it, operate,
on it, etc. Basic operators +, -, *, and / are defined (returning SHEFp).
Comparision operators return SHEBool and can be used in a select function:

SHEFp select(&SHEBool sel,const SHEFp &a_true, const SHEFp &a_false);
version also allow mixing in floating point constants as well. 

SHEString operations

String operations are still under construction
  
Performance and bootstrapping.

While pretty much anything you want to do with Integers and Doubles is support,
not everything can be done in finite time. While the library 'hides' the
details of underlying bootstrapping operations, they will quickly become
appearant in your application. For any real security level, bootstrapping
large integers, like 64 bits, can take 3-4 hours to complete. So while you
may be able to do some operation in multiple seconds, when you run close to
the noise limit, they can suddenly take hours. There are a couple of ways to
mitigate this issue.

   1) you can select a high noise tolerance context and try to complete your
   entire calculation before bootstrapping becomes necessary.
   2) you can use a lower noise tolerance to get faster performance for the
   same security level.
   3) you can reduce your security level.
   4) you can reduce your integer size.

For almost all usable security levels, SHEInt64 will have extremely poor
performance. SHEInt16 will have the best compromise of performance and
functionality. If you do have to boostrap, you can use the .bitCapacity()
method to see how many more operations your variable can go before it needs
to bootstrap. There is also a useful method (.verifyArgs()) that will
preemptively bootstrap those variables before you execute a particular
function. This is important because you may find that while SHELib can
automatically bootstrap, it may bootstrap temparary copies, leaving the
original variable unupdated. Also bootstrapping a variable that may be
used in multiple locations helps keep



